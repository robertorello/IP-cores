library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use IEEE.std_logic_unsigned.all;

entity TFG_RX_MARK_29 is
  port (
    clk              : in std_logic;
    inicio           : in std_logic;

    -- I/O MENÚ DE SELECCIION DE SENSORES
    selector         : in std_logic; -- Botón que alterna entre SELECCION_VIS y MEDIDA_VIS

    -- I/0 DS10B20
    data_bus_ds18b20 : inout std_logic;
    -- I/O DHT11
    data_bus_dht11   : inout std_logic;

    -- I/O HCSRO4
    trig             : out std_logic;
    echo             : in std_logic;

    -- I/O VISUALIZACIÓN
    segmentos        : out std_logic_vector (6 downto 0);
    enable_seg       : out std_logic_vector (3 downto 0);

    -- I/O DEPURACIÓN DE LEDS
    led              : out std_logic_vector (7 downto 0);

    -- I/0 COMUNICACIÓN UART RX
    serialRX         : in std_logic

  );
end TFG_RX_MARK_29;

architecture Behavioral of TFG_RX_MARK_29 is

  type modo is (
    PANT_INICIO,
    TEMPDS18B20,
    TEMPDHT11,
    HUMDHT11,
    DISHCSR04
  );

  type modo_visualizacion is (
    SELECCION_VIS,
    MEDIDA_VIS
  );

  -- SIGNALS COMUNICACIÓN DS18B20
  ------------------------------------------------------------------------
  type ESTADOS_DS18B20 is (
    ESPERA_800ms,
    RESET,
    PRESENCIA,
    ENVIAR_ROM,
    ESCRIBIR_BYTE,
    ESCRIBIR_BAJO,
    ESCRIBIR_ALTO,
    OBTENER_DATA,
    LEER_BIT
  );
  type ESTADOS_CALC_DEC is (
    CALCULAR_INT, -- Calcular temp_deci_int
    CALCULAR_ESC, -- Calcular temp_deci_esc
    CALCULAR_BCD -- Calcular bcd_decimas y bcd_centesimas
  );
  signal estado_calc_dec   : ESTADOS_CALC_DEC := CALCULAR_INT;
  signal temp_deci_int     : integer range 0 to 15;
  signal temp_deci_esc     : integer range 0 to 99;
  signal temperatura       : std_logic_vector (15 downto 0);
  signal estado_conv_temp  : std_logic_vector (3 downto 0);
  signal vector_aux_temp   : std_logic_vector (31 downto 0);
  signal cont_pasos_temp   : integer range 0 to 15;
  signal dec_temp          : std_logic_vector (3 downto 0);
  signal uni_temp          : std_logic_vector (3 downto 0);

  signal cnt_bit           : integer range 0 to 71;
  signal estado_ds18b20    : ESTADOS_DS18B20 := RESET;
  signal data              : std_logic_vector (71 downto 0);
  signal s_reset           : std_logic;
  signal i                 : integer range 0 to 799999 := 0;
  signal comando_escritura : std_logic_vector (7 downto 0);
  signal senal_presencia   : std_logic;
  signal cont_escr_byte    : integer range 0 to 8 := 0;

  type estados_ENVIAR is (
    SKIP_ROM_1,
    CONVERT_T,
    WAIT_ROM,
    SKIP_ROM_2,
    READ_SCRATCHPAD,
    COGER_DATA
  );

  signal estado_ENVIAR     : estados_ENVIAR := SKIP_ROM_1;
  signal estado_escr_bajo  : integer range 0 to 2 := 0;
  signal estado_escr_alto  : integer range 0 to 2 := 0;
  signal estado_leer_bit   : integer range 0 to 3 := 0;
  signal cont_obtener_data : integer range 0 to 72 := 0;
  signal cont_aux          : integer range 0 to 100;
  signal dataOut           : std_logic_vector (71 downto 0);
  signal temperatura_vec   : std_logic_vector (7 downto 0);
  signal temperatura_int   : integer range 0 to 200; -- No usado

  signal bcd_decimas       : std_logic_vector (3 downto 0) := "0000"; -- Para Display 1
  signal bcd_centesimas    : std_logic_vector (3 downto 0) := "0000"; -- Para Display 0 (LSB)

  constant ERROR_PRESENCIA : std_logic_vector (71 downto 0) := (others => '1');
  -- SIGNALS PROCESS COMUNICACIÓN DHT11
  ------------------------------------------------------------------------

  type estados_dht11 is (
    REPOSO,
    INICIO_1_8_MS,
    PRESENCIA_DHT,
    IN_COM_BAJO_80US,
    IN_COM_ALTO_80US,
    PULS_BAJO_VAR_50US,
    PULS_ALTO_VAR,
    ALMAC_ALTO_DHT11,
    ALMAC_BAJO_DHT11,
    CONTROL_CONT_BITS,
    GENERAR_CHECKSUM,
    CONTROL_CHECKSUM,
    FINAL_LECTURA,
    ESTADO_ERROR_CHECKSUM,
    ESTADO_ERROR_TIMMING
  );

  signal estado_dht11      : estados_dht11 := REPOSO;
  signal cont_bits_dht11   : integer range 0 to 40;
  signal h                 : integer range 0 to 200_000_000;
  signal datos_recibidos   : std_logic_vector (39 downto 0);
  signal check_sum         : std_logic_vector (7 downto 0);
  signal error_checksum    : std_logic;
  signal error_timming     : std_logic;

  signal estado_flanco_asc : std_logic_vector (2 downto 0);
  signal estado_flanco_desc: std_logic_vector (2 downto 0);
  signal flanco_asc        : std_logic;
  signal flanco_desc       : std_logic;

  signal estado_pulso      : std_logic_vector (1 downto 0);
  signal pulso_sal         : std_logic;
  signal cont_pulso        : integer range 0 to 1_000_000;


  -- SIGNALS PROCESS COMUNICACIÓN HC-SR04
  -----------------------------------------------------------------------

  type estados_hc is (
    INICIO_HC,
    TRIGGER_HC,
    ESPERA_1_HC,
    RETARDO_ECHO_HC,
    MIDE_HC,
    ESPERA_2_HC
  );

  signal estado_hc   : estados_hc;
  signal dist        : integer range 0 to 400;
  signal dist_temp   : integer range 0 to 400;
  signal hc          : integer range 0 to 10000000;
  signal cont_echo   : integer range 0 to 100000;
  signal cont_aux_hc : integer range 0 to 100000;
  signal cont_freq   : integer range 0 to 100;
  signal temp        : integer range 0 to 50000000;
  signal dist_mil    : std_logic_vector(3 downto 0);
  signal dist_cen    : std_logic_vector(3 downto 0);
  signal dist_dec    : std_logic_vector(3 downto 0);
  signal dist_uni    : std_logic_vector(3 downto 0);

  -- SIGNALS DEPURACION
  ------------------------------------------------------------------------
  signal error_checksum_sal : std_logic;
  signal error_timming_sal  : std_logic;

  -- SIGNALS DE VISUALIZACIÓN 7SEGMENTOS
  ------------------------------------------------------------------------
  signal numeracion         : std_logic_vector (7 downto 0);
  signal enable_aux         : std_logic_vector (3 downto 0);
  signal cont_base_enable   : integer range 0 to 10000000;
  signal sal_mux            : std_logic_vector (3 downto 0);

  -- SIGNALS CONVERSION BCD (DOUBLE DABBLE)
  ------------------------------------------------------------------------
  signal temp_ent_dht11_uni  : std_logic_vector (3 downto 0);
  signal temp_ent_dht11_dec  : std_logic_vector (3 downto 0);
  signal temp_deci_dht11_uni : std_logic_vector (3 downto 0);
  signal temp_deci_dht11_dec : std_logic_vector (3 downto 0);
  signal hum_dht11_uni       : std_logic_vector (3 downto 0);
  signal hum_dht11_dec       : std_logic_vector (3 downto 0);

  signal vector_aux_temp_ent_dht11  : std_logic_vector (15 downto 0);
  signal vector_aux_temp_deci_dht11 : std_logic_vector (15 downto 0);
  signal vector_aux_hum_dht11       : std_logic_vector (15 downto 0);

  signal estado_conv_temp_ent_dht11  : std_logic_vector (3 downto 0);
  signal estado_conv_temp_deci_dht11 : std_logic_vector (3 downto 0);
  signal estado_conv_hum_dht11       : std_logic_vector (3 downto 0);

  signal cont_pasos_conv_temp_ent_dht11  : integer range 0 to 8;
  signal cont_pasos_conv_temp_deci_dht11 : integer range 0 to 8;
  signal cont_pasos_conv_hum_dht11       : integer range 0 to 8;

  signal seleccion_actual    : modo := PANT_INICIO;
  signal visualizacion       : modo_visualizacion := SELECCION_VIS;
  signal hum_ent_dht11       : std_logic_vector(7 downto 0);
  signal temp_ent_dht11      : std_logic_vector(7 downto 0);
  signal temp_deci_dht11     : std_logic_vector(7 downto 0);
  signal inicio_filtrado       : std_logic;
  signal selector_filtrado     : std_logic;
  signal selector_filtrado_ant : std_logic;

  -- SIGNALS COMUNICACIÓN UART RX
  --------------------------------------------------------------------------------

  constant NUM_BITS  : integer := 8;
  constant NUM_START : integer := 1;
  constant NUM_STOP  : integer := 1;
  constant FREQ_CLK  : integer := 100000000;
  constant BPS       : integer := 9600; --19200, 38400, 57600 y 115200

  type ESTADO is (
    REPOSO,
    START,
    RX,
    STOP
  );

  signal estado_rx    : ESTADO;
  signal cont_uart_rx : integer range 0 to 2000000;
  signal cont_bit_rx  : integer range 0 to NUM_BITS;
  signal entrada_rx   : std_logic;
  signal salida_rx    : std_logic_vector (7 downto 0);
  signal salida_uart  : std_logic_vector (7 downto 0);
  signal pulsos_bps   : integer range 0 to 11000;

  -- CONSTANTES (FILTRADO Y CARACTERES 7SEG)
  --------------------------------------------------------------------------------
  constant tiempo_filtro : integer := 1000;
  constant caracter_S    : std_logic_vector(3 downto 0) := "0101";
  constant caracter_r    : std_logic_vector(3 downto 0) := "1010";
  constant caracter_H    : std_logic_vector(3 downto 0) := "1011";
  constant caracter_T    : std_logic_vector(3 downto 0) := "1100";
  constant caracter_dash : std_logic_vector(3 downto 0) := "1101";
  constant caracter_off  : std_logic_vector(3 downto 0) := "1110";
  constant caracter_d    : std_logic_vector(3 downto 0) := "1111";

  -- DECLARACION FUNCION FILTRO_DIGITAL
  ---------------------------------------------------------------------------------
  component filtro_digital is
    port(
      clk             : in std_logic;
      inicio          : in std_logic;
      entrada         : in std_logic;
      salida_filtrada : out std_logic;
      tope_filtro     : in integer range 0 to 1000000000
    );
  end component;

begin

  filtro_digital_inicio : filtro_digital
    port map(
      clk             => clk,
      inicio          => inicio,
      entrada         => inicio,
      salida_filtrada => inicio_filtrado,
      tope_filtro     => tiempo_filtro
    );

  filtro_digital_selector : filtro_digital
    port map(
      clk             => clk,
      inicio          => inicio,
      entrada         => selector,
      salida_filtrada => selector_filtrado,
      tope_filtro     => tiempo_filtro
    );

  process(clk, inicio_filtrado) -- PROCESS DE ADMINISTRACIÓN DEL MENÚ
  begin
    if inicio_filtrado = '1' then
      seleccion_actual <= PANT_INICIO;
    elsif rising_edge(clk) then
      case (unsigned(numeracion)) is
        when "000" => seleccion_actual <= PANT_INICIO;
        when "001" => seleccion_actual <= TEMPDS18B20;
        when "010" => seleccion_actual <= TEMPDHT11;
        when "011" => seleccion_actual <= HUMDHT11;
        when "100" => seleccion_actual <= DISHCSR04;
        when others => seleccion_actual <= PANT_INICIO;
      end case;
    end if;
  end process;

  -- PROCESS DE SELECCIÓN DEL MODO DE VISUALIZACIÓN (SELECCION_VIS y MEDIDA_VIS)
  process(clk, inicio_filtrado)
  begin
    if inicio_filtrado = '1' then
      visualizacion <= SELECCION_VIS;
      selector_filtrado_ant <= '0';
    elsif rising_edge(clk) then
      if selector_filtrado = '1' and selector_filtrado_ant = '0' then
        if visualizacion = SELECCION_VIS then
          visualizacion <= MEDIDA_VIS;
        else
          visualizacion <= SELECCION_VIS;
        end if;
      end if;
      selector_filtrado_ant <= selector_filtrado;
    end if;
  end process;

  -- PROCESS PRINCIPAL COMUNICACIÓN DS18B20
  -------------------------------------------------------------------------
  process(clk, cont_aux)
  begin
    if rising_edge(clk) and cont_aux=0 then
      case estado_ds18b20 is
        when RESET =>
          S_reset <= '0';
          if (i = 0) then
            data_bus_ds18b20 <= '0';
          elsif (i = 485) then
            data_bus_ds18b20 <= 'Z';
          elsif (i = 550) then
            senal_presencia <= data_bus_ds18b20;
          elsif (i = 1000) then
            estado_ds18b20 <= PRESENCIA;
          end if;
        when PRESENCIA =>
          if (senal_presencia = '0' and data_bus_ds18b20 = '1') then
            S_reset <= '1';
            estado_ds18b20 <= ENVIAR_ROM;
          else
            S_reset <= '1';
            dataOut <= ERROR_PRESENCIA;
            estado_ds18b20 <= ESPERA_800MS;
          end if;
        when ENVIAR_ROM =>
          if (estado_ENVIAR = SKIP_ROM_1) then
            estado_ENVIAR <= CONVERT_T;
            comando_escritura <="11001100";
            estado_ds18b20 <= ESCRIBIR_BYTE;
          elsif (estado_ENVIAR = CONVERT_T) then
            estado_ENVIAR <= WAIT_ROM;
            comando_escritura <="01000100";
            estado_ds18b20 <= ESCRIBIR_BYTE;
          elsif (estado_ENVIAR = WAIT_ROM) then
            estado_ENVIAR <= SKIP_ROM_2;
            estado_ds18b20 <= ESPERA_800MS;
          elsif (estado_ENVIAR = SKIP_ROM_2) then
            estado_ENVIAR <= READ_SCRATCHPAD;
            comando_escritura <="11001100";
            estado_ds18b20 <= ESCRIBIR_BYTE;
          elsif (estado_ENVIAR = READ_SCRATCHPAD) then
            estado_ENVIAR <= COGER_DATA;
            comando_escritura <="10111110";
            estado_ds18b20 <= ESCRIBIR_BYTE;
          elsif (estado_ENVIAR = COGER_DATA) then
            estado_ENVIAR <= SKIP_ROM_1;
            estado_ds18b20 <= OBTENER_DATA;
          end if;
        when ESPERA_800MS =>
          S_reset <= '0';
          if (i = 799) then
            S_reset <='1';
            estado_ds18b20 <= RESET;
          end if;
        when OBTENER_DATA =>
          case cont_obtener_data is
            when 0 to 71=>
              data_bus_ds18b20 <= '0';
              cont_obtener_data <= cont_obtener_data + 1;
              estado_ds18b20 <= LEER_BIT;
            when 72=>
              cnt_bit <= 0;
              cont_obtener_data <=0;
              dataOut <= data(71 downto 0);
              estado_ds18b20 <= ESPERA_800MS;
            when others =>
              estado_leer_bit <= 0;
              cont_obtener_data <= 0;
          end case;
        when LEER_BIT =>
          case estado_leer_bit is
            when 0=>
              estado_leer_bit <= 1;
            when 1=>
              data_bus_ds18b20 <= 'Z';
              S_reset <= '0';
              if (i = 13) then
                s_reset <= '1';
                estado_leer_bit <= 2;
              end if;
            when 2=>
              data(cnt_bit) <= data_bus_ds18b20;
              cnt_bit <= cnt_bit + 1;
              estado_leer_bit <= 3;
            when 3=>
              S_reset <= '0';
              if (i = 63) then
                S_reset<='1';
                estado_leer_bit <= 0;
                estado_ds18b20 <= OBTENER_DATA;
              end if;
            when others =>
              estado_leer_bit <= 0;
              cnt_bit <= 0;
              cont_obtener_data <= 0;
              estado_ds18b20 <= RESET;
          end case;
        when ESCRIBIR_BYTE =>
          case cont_escr_byte is
            when 0 to 7=>
              if (comando_escritura(cont_escr_byte) = '0') then
                estado_ds18b20 <= ESCRIBIR_BAJO;
              else
                estado_ds18b20 <= ESCRIBIR_ALTO;
              end if;
              cont_escr_byte <= cont_escr_byte + 1;
            when 8=>
              cont_escr_byte <= 0;
              estado_ds18b20 <= ENVIAR_ROM;
            when others=>
              cont_escr_byte <= 0;
              estado_escr_bajo <= 0;
              estado_escr_alto <= 0;
              estado_ds18b20 <= RESET;
          end case;
        when ESCRIBIR_BAJO =>
          case estado_escr_bajo is
            when 0=>
              data_bus_ds18b20 <= '0';
              S_reset <= '0';
              if (i = 59) then
                S_reset <='1';
                estado_escr_bajo <= 1;
              end if;
            when 1=>
              data_bus_ds18b20 <= 'Z';
              S_reset <= '0';
              if (i = 3) then
                S_reset <= '1';
                estado_escr_bajo <= 2;
              end if;
            when 2=>
              estado_escr_bajo <= 0;
              estado_ds18b20 <= ESCRIBIR_BYTE;
            when others=>
              cont_escr_byte <= 0;
              estado_escr_bajo <= 0;
              estado_ds18b20 <= RESET;
          end case;
        when ESCRIBIR_ALTO =>
          case estado_escr_alto is
            when 0=>
              data_bus_ds18b20 <= '0';
              S_reset <= '0';
              if (i = 9) then
                S_reset <= '1';
                estado_escr_alto <= 1;
              end if;
            when 1=>
              data_bus_ds18b20 <= 'Z';
              S_reset <= '0';
              if (i = 53) then
                S_reset <= '1';
                estado_escr_alto <= 2;
              end if;
            when 2=>
              estado_escr_alto <= 0;
              estado_ds18b20 <= ESCRIBIR_BYTE;
            when others =>
              cont_escr_byte <= 0;
              estado_escr_alto <= 0;
              estado_ds18b20 <= RESET;
          end case;
        when others =>
          estado_ds18b20 <= RESET;
      end case;
    end if;
  end process;

  -- PROCESS AUXILIARES
  ----------------------------------------------------------------
  process(clk, S_reset)
  begin
    if (rising_edge(clk)) then
      if cont_aux=100 then
        cont_aux<=0;
        if (S_reset = '1')then
          i <= 0;
        else
          i <= i + 1;
        end if;
      else
        cont_aux<=cont_aux+1;
      end if;
    end if;
  end process;

  -- PROCESS ASIGNACION TEMP
  -------------------------------------------------------------------------
  -- Combina bits 11-8 y 7-4 de 'dataOut' (lectura estable) para parte entera.
  process(inicio, clk)
  begin
    if inicio = '1' then
      temperatura_vec <= (others => '0');
    elsif (rising_edge(clk)) then
      temperatura_vec <= dataOut(11 downto 8) & dataOut (7 downto 4);
    end if;
  end process;

  temperatura <= "00000000" & temperatura_vec;

  -- PROCESS CONVERSION BCD PARTE ENTERA
  ------------------------------------------------------------------------
  process (inicio, clk)
  begin
    if inicio = '1' then
      estado_conv_temp <= "0000";
      vector_aux_temp <= "0000000000000000" & temperatura;
      cont_pasos_temp <= 0;
      dec_temp <= "0000";
      uni_temp <= "0000";
    elsif rising_edge(clk) then
      case estado_conv_temp is
        when "0000" =>
          vector_aux_temp <= "0000000000000000" & temperatura;
          cont_pasos_temp <= 0;
          estado_conv_temp <= "0001";
        when "0001" =>
          vector_aux_temp <= vector_aux_temp (30 downto 0) & '0';
          cont_pasos_temp <= cont_pasos_temp + 1;
          if cont_pasos_temp < 15 then
            estado_conv_temp <= "0010";
          else
            estado_conv_temp <= "1000";
          end if;
        when "0010" =>
          if vector_aux_temp (31 downto 28) > "0100" then
            vector_aux_temp (31 downto 28) <= vector_aux_temp (31 downto 28) + "0011";
          end if;
          if vector_aux_temp (27 downto 24) > "0100" then
            vector_aux_temp(27 downto 24) <= vector_aux_temp (27 downto 24) + "0011";
          end if;
          if vector_aux_temp (23 downto 20) > "0100" then
            vector_aux_temp (23 downto 20) <= vector_aux_temp (23 downto 20) + "0011";
          end if;
          if vector_aux_temp (19 downto 16) > "0100" then
            vector_aux_temp (19 downto 16) <= vector_aux_temp (19 downto 16) + "0011";
          end if;
          estado_conv_temp <= "0001";
        when "1000" =>
          dec_temp <= vector_aux_temp (23 downto 20);
          uni_temp <= vector_aux_temp (19 downto 16);
          estado_conv_temp <= "0000";
        when others =>
          estado_conv_temp <= "0000";
      end case;
    end if;
  end process;

  -- PROCESS CONVERSION BCD DECIMALES
  --------------------------------------------------------------------------
  process(clk, inicio)
  begin
    if inicio = '1' then
      temp_deci_int <= 0;
      temp_deci_esc <= 0;
      bcd_decimas <= (others => '0');
      bcd_centesimas <= (others => '0');
      estado_calc_dec <= CALCULAR_INT;
    elsif rising_edge(clk) then
      case estado_calc_dec is
        when CALCULAR_INT =>
          -- Etapa 1: Extrae los 4 bits fraccionarios y almacena en temp_deci_int
          temp_deci_int <= to_integer(unsigned(dataOut(3 downto 0)));
          estado_calc_dec <= CALCULAR_ESC;
        when CALCULAR_ESC =>
          -- Etapa 2: Usa el temp_deci_int calculado en el ciclo anterior
          temp_deci_esc <= (temp_deci_int * 100) / 16;
          estado_calc_dec <= CALCULAR_BCD;
        when CALCULAR_BCD =>
          -- Etapa 3: Usa el temp_deci_esc calculado en el ciclo anterior
          bcd_decimas <= std_logic_vector(to_unsigned((temp_deci_esc / 10) mod 10, 4));
          bcd_centesimas <= std_logic_vector(to_unsigned(temp_deci_esc mod 10, 4));
          estado_calc_dec <= CALCULAR_INT;
        when others =>
          estado_calc_dec <= CALCULAR_INT;
      end case;
    end if;
  end process;

  -- PROCESS AUXILIARES COMUNICACION DHT11
  -------------------------------------------------------------------------------

  -- PROCESS PRINCIPAL COMUNICACION DHT11
  -------------------------------------------------------------------------------

  process(clk, inicio) -- MANEJO DE FLANCOS ASCENDENTES (1)
  begin
    if rising_edge(clk) then
      if inicio = '1' then
        estado_flanco_asc <= "000";
      else
        case estado_flanco_asc is
          when "000" =>
            if data_bus_dht11 = '1' then
              estado_flanco_asc <= "001";
            end if;
          when "001" =>
            if data_bus_dht11 = '1' then
              estado_flanco_asc <= "010";
            end if;
          when "010" =>
            if data_bus_dht11 = '1' then
              estado_flanco_asc <= "011";
            end if;
          when "011" =>
            if data_bus_dht11 = '1' then
              estado_flanco_asc <= "100";
            end if;
          when "100" =>
            if data_bus_dht11 = '0' then
              estado_flanco_asc<="000";
            end if;
          when others =>
            estado_flanco_asc<="000";
        end case;
      end if;
    end if;
  end process;

  process (estado_flanco_asc) -- MANEJO DE FLANCOS ASCENDENTES (2)
  begin
    case estado_flanco_asc is
      when "000" => flanco_asc <= '0';
      when "001" => flanco_asc <= '0';
      when "010" => flanco_asc <= '0';
      when "011" => flanco_asc <= '1';
      when "100" => flanco_asc <= '0';
      when others => flanco_asc <= '0';
    end case;
  end process;

  process(clk, inicio) -- MANEJO DE FLANCOS DESCENDENTES (1)
  begin
    if rising_edge(clk) then
      if inicio = '1' then
        estado_flanco_desc <= "000";
      else
        case estado_flanco_desc is
          when "000" =>
            if data_bus_dht11 = '0' then
              estado_flanco_desc <= "001";
            end if;
          when "001" =>
            if data_bus_dht11 = '0' then
              estado_flanco_desc <= "010";
            end if;
          when "010" =>
            if data_bus_dht11 = '0' then
              estado_flanco_desc <= "011";
            end if;
          when "011" =>
            if data_bus_dht11 = '0' then
              estado_flanco_desc <= "100";
            end if;
          when "100" =>
            if data_bus_dht11 = '1' then
              estado_flanco_desc <= "000";
            end if;
          when others =>
            estado_flanco_desc <= "000";
        end case;
      end if;
    end if;
  end process;

  process (estado_flanco_desc) -- MANEJO DE FLANCOS DESCENDENTES (2)
  begin
    case estado_flanco_desc is
      when "000" => flanco_desc <= '0';
      when "001" => flanco_desc <= '0';
      when "010" => flanco_desc <= '0';
      when "011" => flanco_desc <= '1';
      when "100" => flanco_desc <= '0';
      when others => flanco_desc <= '0';
    end case;
  end process;

  -- PROCESS DE COMUNICACIÓN DEL SENSOR DHT11
  --------------------------------------------------------------------------
  process(clk, inicio)
  begin
    if rising_edge(clk) then
      if inicio = '1' then
        h <= 0;
        cont_bits_dht11 <= 0;
        datos_recibidos <= (others => '0');
        data_bus_dht11 <= 'Z';
        hum_ent_dht11 <= (others => '0');
        temp_ent_dht11 <= (others=>'0');
        temp_deci_dht11 <= (others => '0');
        error_checksum <= '0';
        error_timming <= '0';
      else
        case estado_dht11 is
          when REPOSO =>
            if h = 100_000_000 then
              h <= 0;
              data_bus_dht11 <= '0';
              cont_bits_dht11 <= 0;
              datos_recibidos <= (others => '0');
              error_checksum <= '0';
              error_timming <= '0';
              estado_dht11 <= INICIO_1_8_MS;
            else
              h <= h + 1;
            end if;
          when INICIO_1_8_MS =>
            if h = 1_800_000 then
              h <= 0;
              data_bus_dht11 <= 'Z';
              estado_dht11 <= PRESENCIA_DHT;
            else
              h <= h + 1;
            end if;
          when PRESENCIA_DHT =>
            if flanco_desc = '1' then
              h <= 0;
              estado_dht11 <= IN_COM_BAJO_80US;
            else
              if h > 4_500 then
                estado_dht11 <= ESTADO_ERROR_TIMMING;
              else
                h <= h + 1;
              end if;
            end if;
          when IN_COM_BAJO_80US =>
            if flanco_asc = '1' then
              h <= 0;
              estado_dht11 <= IN_COM_ALTO_80US;
            else
              if h > 8_800 then
                estado_dht11 <= ESTADO_ERROR_TIMMING;
              else
                h <= h + 1;
              end if;
            end if;
          when IN_COM_ALTO_80US =>
            if flanco_desc = '1' then
              h <= 0;
              estado_dht11 <= PULS_BAJO_VAR_50US;
            else
              if h > 8_800 then
                estado_dht11 <= ESTADO_ERROR_TIMMING;
              else
                h <= h + 1;
              end if;
            end if;
          when PULS_BAJO_VAR_50US =>
            if flanco_asc = '1' then
              h <= 0;
              estado_dht11 <= PULS_ALTO_VAR;
            else
              if h > 5_500 then
                estado_dht11 <= ESTADO_ERROR_TIMMING;
              else
                h <= h+1;
              end if;
            end if;
          when PULS_ALTO_VAR =>
            if flanco_desc = '1' then
              if h < 3_000 then
                estado_dht11 <= ALMAC_BAJO_DHT11;
              else
                estado_dht11 <= ALMAC_ALTO_DHT11;
              end if;
            else
              if h > 7_700 then
                estado_dht11 <= ESTADO_ERROR_TIMMING;
              else
                h <= h + 1;
              end if;
            end if;
          when ALMAC_ALTO_DHT11 =>
            cont_bits_dht11 <= cont_bits_dht11 + 1;
            datos_recibidos <= datos_recibidos(38 downto 0) & '1';
            estado_dht11 <= CONTROL_CONT_BITS;
          when ALMAC_BAJO_DHT11 =>
            cont_bits_dht11 <= cont_bits_dht11 + 1;
            datos_recibidos <= datos_recibidos(38 downto 0) & '0';
            estado_dht11 <= CONTROL_CONT_BITS;
          when CONTROL_CONT_BITS =>
            if cont_bits_dht11 = 40 then
              estado_dht11 <= GENERAR_CHECKSUM;
            else
              h <= 0;
              estado_dht11 <= PULS_BAJO_VAR_50US;
            end if;
          when GENERAR_CHECKSUM =>
            check_sum <= datos_recibidos(39 downto 32) + datos_recibidos(31 downto 24) +
                         datos_recibidos(23 downto 16) + datos_recibidos(15 downto 8);
            estado_dht11 <= CONTROL_CHECKSUM;
          when CONTROL_CHECKSUM =>
            if check_sum /= datos_recibidos(7 downto 0) then
              estado_dht11 <= ESTADO_ERROR_CHECKSUM;
            else
              estado_dht11 <= FINAL_LECTURA;
            end if;
          when FINAL_LECTURA =>
            if h = 5_000 then
              hum_ent_dht11 <= datos_recibidos(39 downto 32);
              temp_ent_dht11 <= datos_recibidos(23 downto 16);
              temp_deci_dht11 <= datos_recibidos(15 downto 8);
              error_checksum_sal <= '0';
              error_timming_sal <= '0';
              h <= 0;
              data_bus_dht11 <= 'Z';
              estado_dht11 <= REPOSO;
            else
              h <= h + 1;
            end if;
          when ESTADO_ERROR_CHECKSUM =>
            error_checksum <= '1';
            estado_dht11<=FINAL_LECTURA;
          when ESTADO_ERROR_TIMMING =>
            error_timming <= '1';
            estado_dht11 <= FINAL_LECTURA;
          when others =>
            estado_dht11 <= REPOSO;
            h <= 0;
            cont_bits_dht11 <= 0;
            datos_recibidos <= (others => '0');
            data_bus_dht11 <= 'Z';
            hum_ent_dht11 <= (others => '0');
            temp_ent_dht11 <= (others=>'0');
            temp_deci_dht11 <= (others => '0');
            error_checksum <= '0';
            error_timming <= '0';
        end case;
      end if;
    end if;
  end process;

  -- PROCESS DE CONVERSION BCD (DOUBLE DABBLE)
  -----------------------------------------------------------------------------------
  process (clk) -- PROCESS CONVERSION HUMEDAD ENTEROS
  begin
    if rising_edge(clk) then
      if inicio = '1' then
        estado_conv_hum_dht11 <= "0000";
        vector_aux_hum_dht11 <= (others => '0');
        cont_pasos_conv_hum_dht11 <= 0;
        hum_dht11_dec <= "0000";
        hum_dht11_uni <= "0000";
      else
        case estado_conv_hum_dht11 is
          when "0000" => -- Inicialización
            vector_aux_hum_dht11 <= "00000000" & hum_ent_dht11;
            cont_pasos_conv_hum_dht11 <= 0;
            estado_conv_hum_dht11 <= "0001";
          when "0001" => -- Ajuste BCD (si >4, suma 3)
            if unsigned(vector_aux_hum_dht11(15 downto 12)) > 4 then
              vector_aux_hum_dht11(15 downto 12) <= std_logic_vector(
                unsigned(vector_aux_hum_dht11(15 downto 12)) + 3);
            end if;
            if unsigned(vector_aux_hum_dht11(11 downto 8)) > 4 then
              vector_aux_hum_dht11(11 downto 8) <= std_logic_vector(
                unsigned(vector_aux_hum_dht11(11 downto 8)) + 3);
            end if;
            estado_conv_hum_dht11 <= "0010";
          when "0010" => -- Desplazamiento a la izquierda
            vector_aux_hum_dht11 <= vector_aux_hum_dht11(14 downto 0) & '0';
            if cont_pasos_conv_hum_dht11 = 7 then
              estado_conv_hum_dht11 <= "1000";
            else
              cont_pasos_conv_hum_dht11 <= cont_pasos_conv_hum_dht11 + 1;
              estado_conv_hum_dht11 <= "0001";
            end if;
          when "1000" => -- Extracción de valores BCD
            hum_dht11_dec <= vector_aux_hum_dht11(15 downto 12);
            hum_dht11_uni <= vector_aux_hum_dht11(11 downto 8);
            estado_conv_hum_dht11 <= "0000";
          when others =>
            estado_conv_hum_dht11 <= "0000";
        end case;
      end if;
    end if;
  end process;

  process (clk) -- PROCESS CONVERSION TEMPERATURA ENTEROS
  begin
    if rising_edge(clk) then
      if inicio = '1' then
        estado_conv_temp_ent_dht11 <= "0000";
        vector_aux_temp_ent_dht11 <= (others => '0');
        cont_pasos_conv_temp_ent_dht11 <= 0;
        temp_ent_dht11_dec <= "0000";
        temp_ent_dht11_uni <= "0000";
      else
        case estado_conv_temp_ent_dht11 is
          when "0000" =>
            vector_aux_temp_ent_dht11 <= "00000000" & temp_ent_dht11;
            cont_pasos_conv_temp_ent_dht11 <= 0;
            estado_conv_temp_ent_dht11 <= "0001";
          when "0001" =>
            if unsigned(vector_aux_temp_ent_dht11(15 downto 12)) > 4 then
              vector_aux_temp_ent_dht11(15 downto 12) <=
                std_logic_vector(unsigned(vector_aux_temp_ent_dht11(15 downto 12)) + 3);
            end if;
            if unsigned(vector_aux_temp_ent_dht11(11 downto 8)) > 4 then
              vector_aux_temp_ent_dht11(11 downto 8) <= std_logic_vector
                (unsigned(vector_aux_temp_ent_dht11(11 downto 8)) + 3);
            end if;
            estado_conv_temp_ent_dht11 <= "0010";
          when "0010" =>
            vector_aux_temp_ent_dht11 <= vector_aux_temp_ent_dht11(14 downto 0) & '0';
            if cont_pasos_conv_temp_ent_dht11 = 7 then
              estado_conv_temp_ent_dht11 <= "1000";
            else
              cont_pasos_conv_temp_ent_dht11 <= cont_pasos_conv_temp_ent_dht11 + 1;
              estado_conv_temp_ent_dht11 <= "0001";
            end if;
          when "1000" =>
            temp_ent_dht11_dec <= vector_aux_temp_ent_dht11(15 downto 12);
            temp_ent_dht11_uni <= vector_aux_temp_ent_dht11(11 downto 8);
            estado_conv_temp_ent_dht11 <= "0000";
          when others =>
            estado_conv_temp_ent_dht11 <= "0000";
        end case;
      end if;
    end if;
  end process;

  process (clk) -- PROCESS CONVERSION TEMPERATURA DECIMALES
  begin
    if rising_edge(clk) then
      if inicio = '1' then
        estado_conv_temp_deci_dht11 <= "0000";
        vector_aux_temp_deci_dht11 <= (others => '0');
        cont_pasos_conv_temp_deci_dht11 <= 0;
        temp_deci_dht11_dec <= "0000";
        temp_deci_dht11_uni <= "0000";
      else
        case estado_conv_temp_deci_dht11 is
          when "0000" => -- Inicialización
            vector_aux_temp_deci_dht11 <= "00000000" & temp_deci_dht11;
            cont_pasos_conv_temp_deci_dht11 <= 0;
            estado_conv_temp_deci_dht11 <= "0001";
          when "0001" => -- Suma 3 BCD (si >4, suma 3)
            if unsigned(vector_aux_temp_deci_dht11(15 downto 12)) > 4 then
              vector_aux_temp_deci_dht11(15 downto 12) <=
                std_logic_vector(unsigned(vector_aux_temp_deci_dht11(15 downto 12)) + 3);
            end if;
            if unsigned(vector_aux_temp_deci_dht11(11 downto 8)) > 4 then
              vector_aux_temp_deci_dht11(11 downto 8) <=
                std_logic_vector(unsigned(vector_aux_temp_deci_dht11(11 downto 8)) + 3);
            end if;
            estado_conv_temp_deci_dht11 <= "0010";
          when "0010" => -- Desplazamiento a la izquierda
            vector_aux_temp_deci_dht11 <= vector_aux_temp_deci_dht11(14 downto 0) & '0';
            if cont_pasos_conv_temp_deci_dht11 = 7 then
              estado_conv_temp_deci_dht11 <= "1000";
            else
              cont_pasos_conv_temp_deci_dht11 <= cont_pasos_conv_temp_deci_dht11 + 1;
              estado_conv_temp_deci_dht11 <= "0001";
            end if;
          when "1000" => -- Extracción de valores BCD
            temp_deci_dht11_dec <= vector_aux_temp_deci_dht11(15 downto 12);
            temp_deci_dht11_uni <= vector_aux_temp_deci_dht11(11 downto 8);
            estado_conv_temp_deci_dht11 <= "0000";
          when others =>
            estado_conv_temp_deci_dht11 <= "0000";
        end case;
      end if;
    end if;
  end process;

  -- PROCESS DE RECEPCIÓN DE TRANSMISIÓN UART
  --------------------------------------------------------------------------
  pulsos_bps <= FREQ_CLK/BPS; --para ejecucion real
  entrada_rx <= serialRX;
  numeracion <= salida_uart;

  process(clk, inicio)
  begin
    if rising_edge(clk) then
      if inicio = '1' then
        salida_rx <="00000000";
        cont_uart_rx <= 0;
        cont_bit_rx <= 0;
        salida_uart <= "00000000";
        estado_rx <= REPOSO;
      else
        case estado_rx is
          when REPOSO =>
            if entrada_rx = '0' then
              cont_uart_rx <= 0;
              cont_bit_rx <= 0;
              estado_rx <= START;
            end if;
          when START =>
            if cont_uart_rx = (pulsos_bps * num_start + (pulsos_bps / 2) - 1) then
              cont_uart_rx <= 0;
              cont_bit_rx <= 1;
              salida_rx <= entrada_rx & salida_rx(7 downto 1);
              estado_rx <= RX;
            else
              cont_uart_rx <= cont_uart_rx + 1;
            end if;
          when RX =>
            if cont_uart_rx = (pulsos_bps - 1) then
              if cont_bit_rx = NUM_BITS - 1 then
                cont_uart_rx <= 0;
                cont_bit_rx <= 0;
                salida_rx <= entrada_rx & salida_rx(7 downto 1);
                estado_rx <= STOP;
              else
                cont_uart_rx <= 0;
                salida_rx <= entrada_rx & salida_rx(7 downto 1);
                cont_bit_rx <= cont_bit_rx + 1;
              end if;
            else
              cont_uart_rx <= cont_uart_rx + 1;
            end if;
          when STOP =>
            if cont_uart_rx = (pulsos_bps * num_stop + pulsos_bps / 2 - 1) then
              estado_rx <= REPOSO;
              salida_uart <= salida_rx;
            else
              cont_uart_rx <= cont_uart_rx + 1;
            end if;
          when others =>
            cont_uart_rx <= 0;
            estado_rx <= REPOSO;
            cont_bit_rx <= 0;
            salida_rx <= "00000000";
            salida_uart <= "00000000";
        end case;
      end if;
    end if;
  end process;

  -- PROCESS DE CONFIGURACION DE 7SEGMENTOS (cont_base_enable, sal_mux, segmentos, etc...)
  -------------------------------------------------------------------------------------------------
  process(inicio, clk) -- Configuración del cont_base_enable
  begin
    if inicio = '1' then
      cont_base_enable <= 0;
    elsif rising_edge(clk) then
      if cont_base_enable = 100000 then
        cont_base_enable <= 0;
      else
        cont_base_enable<=cont_base_enable+1;
      end if;
    end if;
  end process;

  process(clk,inicio) -- PROCESS CONTADOR BASE ENABLE
  begin
    if inicio = '1' then
      enable_aux <= "1101";
    elsif rising_edge(clk) then
      if cont_base_enable = 100000 then
        enable_aux <= enable_aux(2 downto 0) & enable_aux(3);
      end if;
    end if;
  end process;
  --fin de la activación de los siete seg

  enable_seg <= enable_aux;

  -- PROCESS MULTIPLEXADO DE ENTRADAS 7-SEGMENTOS
  -----------------------------------------------------------------------------------
  process(enable_aux, temp_ent_dht11_dec, temp_ent_dht11_uni, temp_deci_dht11,
          temp_deci_dht11_uni, hum_dht11_dec, hum_dht11_uni, dist_mil, dist_cen, dist_dec,
          dist_uni, seleccion_actual, visualizacion)
  begin
    case visualizacion is
      when SELECCION_VIS =>
        case seleccion_actual is
          when PANT_INICIO => -- Pantalla Inicio "rr-0"
            case enable_aux is
              when "0111" => sal_mux <= caracter_r;
              when "1011" => sal_mux <= caracter_r;
              when "1101" => sal_mux <= caracter_dash;
              when "1110" => sal_mux <= "0000";
              when others => sal_mux <= "0000";
            end case;
          when TEMPDS18B20 => -- DS18B20 "ST-1"
            case enable_aux is
              when "0111" => sal_mux <= "0101";
              when "1011" => sal_mux <= caracter_T;
              when "1101" => sal_mux <= caracter_dash;
              when "1110" => sal_mux <= "0001";
              when others => sal_mux <= "0000";
            end case;
          when TEMPDHT11 => -- DHT11 (Temperatura) "ST-2"
            case enable_aux is
              when "0111" => sal_mux <= "0101";
              when "1011" => sal_mux <= caracter_T;
              when "1101" => sal_mux <= caracter_dash;
              when "1110" => sal_mux <= "0010";
              when others => sal_mux <= "0000";
            end case;
          when HUMDHT11 => -- DHT11 (Humedad) "SH-3"
            case enable_aux is
              when "0111" => sal_mux <= "0101";
              when "1011" => sal_mux <= caracter_H;
              when "1101" => sal_mux <= caracter_dash;
              when "1110" => sal_mux <= "0011";
              when others => sal_mux <= "0000";
            end case;
          when DISHCSR04 => -- HC-SR04 (Distancia) "Sd-04"
            case enable_aux is
              when "0111" => sal_mux <= "0101";
              when "1011" => sal_mux <= caracter_d;
              when "1101" => sal_mux <= caracter_dash;
              when "1110" => sal_mux <= "0100";
              when others => sal_mux <= "0000";
            end case;
          when others =>
            sal_mux <= "0000";
        end case;
      when MEDIDA_VIS =>
        case seleccion_actual is
          when PANT_INICIO => -- Pantalla Inicio "---0"
            case enable_aux is
              when "0111" => sal_mux <= "0000";
              when "1011" => sal_mux <= caracter_dash;
              when "1101" => sal_mux <= caracter_dash;
              when "1110" => sal_mux <= caracter_dash;
              when others => sal_mux <= caracter_off;
            end case;
          when TEMPDS18B20 => -- "DDdd" (Por ahora "----")
            case enable_aux is
              when "0111" => sal_mux <= dec_temp;
              when "1011" => sal_mux <= uni_temp;
              when "1101" => sal_mux <= bcd_decimas;
              when "1110" => sal_mux <= bcd_centesimas;
              when others => sal_mux <= caracter_off;
            end case;
          when TEMPDHT11 => -- DHT11 (Temperatura) "TTtt"
            case enable_aux is
              when "0111" => sal_mux <= temp_ent_dht11_dec;
              when "1011" => sal_mux <= temp_ent_dht11_uni;
              when "1101" => sal_mux <= temp_deci_dht11_dec;
              when "1110" => sal_mux <= temp_deci_dht11_uni;
              when others => sal_mux <= caracter_off;
            end case;
          when HUMDHT11 => -- DHT11 (Humedad) "--HH"
            case enable_aux is
              when "0111" => sal_mux <= caracter_dash;
              when "1011" => sal_mux <= caracter_dash;
              when "1101" => sal_mux <= hum_dht11_dec;
              when "1110" => sal_mux <= hum_dht11_uni;
              when others => sal_mux <= caracter_off;
            end case;
          when DISHCSR04 => -- HCSR04 (Distancia) "dddd"
            case enable_aux is
              when "0111" => sal_mux <= dist_mil;
              when "1011" => sal_mux <= dist_cen;
              when "1101" => sal_mux <= dist_dec;
              when "1110" => sal_mux <= dist_uni;
              when others => sal_mux <= caracter_off;
            end case;
          when others =>
            sal_mux <= "1111";
        end case;
    end case;
  end process;

  -- PROCESS DECODIFICADOR 7-SEGMENTOS
  --------------------------------------------------------------------------
  process(sal_mux)
  begin
    case sal_mux is
      when "0000" => segmentos <= "0000001";
      when "0001" => segmentos <= "1001111";
      when "0010" => segmentos <= "0010010";
      when "0011" => segmentos <= "0000110";
      when "0100" => segmentos <= "1001100";
      when "0101" => segmentos <= "0100100";
      when "0110" => segmentos <= "1100000";
      when "0111" => segmentos <= "0001111";
      when "1000" => segmentos <= "0000000";
      when "1001" => segmentos <= "0001100";
      when caracter_r => segmentos <= "1111010";
      when caracter_T => segmentos <= "0111001";
      when caracter_dash => segmentos <= "1111110";
      when caracter_off => segmentos <= "1111111";
      when caracter_H => segmentos <= "1001000";
      when caracter_d => segmentos <= "1000010";
      when others => segmentos <= "1111111";
    end case;
  end process;
end Behavioral;
